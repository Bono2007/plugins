var exports=function(n){"use strict";async function o(n,o,t){var e,a;const{index:s}=await CommandBar.showOptions(o.map((n=>n.label)),n);return null!==(e=null===(a=o[s])||void 0===a?void 0:a.value)&&void 0!==e?e:t}const t=/\B#([a-zA-Z0-9]+\b)/g,e=/\B@([a-zA-Z0-9]+\b)/g,a=/\B(!+\B)/g,s=/^\s*\(([a-zA-z])\)\B/g,c=["open","scheduled","done","cancelled"];function l(n,o){const t=[];let e=o.exec(n);do{var a;(null===(a=e)||void 0===a?void 0:a.length)>1&&t.push(e[1].trim())}while(null!==(e=o.exec(n)));return t}function r(n){let o=-1;return o=n.exclamations[0]?n.exclamations[0].length:n.parensPriority[0]?n.parensPriority[0].charCodeAt(0)-"A".charCodeAt(0)+1:-1,o}const i=n=>{const o=Array.isArray(n)?n[0]:n;return"string"==typeof o?o.toLowerCase():o};function g(n,o){const t="string"==typeof o?[o]:o;return n.sort((n=>(o,t)=>n.map((n=>{let e=1;return"-"===n[0]&&(e=-1,n=n.substring(1)),void 0===i(o[n])?e:void 0===i(t[n])?-e:i(o[n])>i(t[n])?e:i(o[n])<i(t[n])?-e:0})).reduce(((n,o)=>n||o),0))(t)),n}const u=[{sortFields:["-priority","content"],name:"Priority (!!! and (A))"}];function p(n,o,t="",e=""){const a=t?"".concat(t,"\n"):"",s=o.map((n=>n.raw)).join("\n");n.insertParagraph("".concat(a).concat(s).concat(e?"\n".concat(e):""),1,"text")}function d(n,o=u[0].sortFields){const i={};if(n){const u=n.paragraphs;if(console.log("\t".concat(u.length," total lines in note")),u.length){const n=function(n){const o={};c.forEach((n=>o[n]=[]));for(let i=0;i<n.length;i++){const g=n[i];if(c.indexOf(g.type)>=0){const n=g.content;try{const c=l(n,t),u=l(n,e),p=l(n,a),d=l(n,s),h={content:g.content,index:i,raw:g.rawContent,hashtags:c,mentions:u,exclamations:p,parensPriority:d};h.priority=r(h),o[g.type].push(h)}catch(n){console.log(n,g.content,i)}}}return console.log("Tasks:".concat(o.open.length," returning from getTasksByType")),o}(u);console.log("Open Tasks:".concat(n.open.length));for(const t of c)i[t]=g(n[t],o);console.log("After Sort - Open Tasks:".concat(i.open.length))}}else console.log("sorttasksInNote: no note to sort");return i}function h(n,o){const t=n.paragraphs.filter((n=>n.rawContent===o));return t&&t.length>1&&console.log("Found ".concat(t.length,' identical occurrences for "').concat(o,'". Deleting the first.')),t[0]||null}async function f(n){const o="_Task-sort-backup",t="".concat("@Trash","/").concat(o,".").concat(DataStore.defaultFileExtension);console.log("\tBackup filename: ".concat(t));let e=await DataStore.projectNoteByTitle(o,!1,!0);if(console.log("\tGot note back: ".concat(e?JSON.stringify(e):"")),!e||!e.length){console.log("\tsaveBackup: no note named ".concat(t));const n=await DataStore.newNote("_Task-sort-backup","@Trash");await CommandBar.showOptions(["OK"],"Backing up todos in @Trash/".concat(o)),console.log("\tCreated ".concat(n||""," for backups")),e=await DataStore.projectNoteByTitle(o,!1,!0),console.log("backup file contents:\n".concat(e?JSON.stringify(e):""))}e&&e[0]&&(e[0].insertParagraph("---",2,"text"),console.log("BACKUP"),await p(e[0],n))}return n.markTasks=async function(n,t=!0){console.log("Starting markTasks(markDone=".concat(n||"null",")"));let e=null;n||(e=await o("Mark all tasks in note as:",[{label:"Open",value:"open"},{label:"Completed",value:"done"},{label:"Cancel",value:null}],"Cancel"));let a="";if("Cancel"!==e){{const n="Confirm: Mark ALL ".concat("open"===e?"Completed":"Open"," tasks as: ").concat("open"===e?"Open":"Completed","?");t&&(a=await async function(n,o="OK"){return await CommandBar.showInput(n,o)}(n,"Yes"),console.log("User said: ".concat(a?"cancelled":"Yes")))}await async function(n){const o=Editor.paragraphs;let t,e;console.log("setTasks: ".concat(String(o.length||"zero")," paragraphs")),console.log("setTasks; setting to: ".concat(n||"null")),"open"===n?(t="done",e="open"):(t="open",e="done"),o.forEach(((n,o)=>{console.log("".concat(o,": ").concat(n.type," ").concat(n.content," ").concat(n.type===t?">> SETTING TO: ".concat(e):"")),n.type===t&&(n.type=e),Editor.updateParagraph(n)}))}(e)}else console.log("User chose Cancel")},n.sortTasks=async function(n=!0,t=u[0].sortFields,e=null){console.log("\nStarting sortTasks():");const a=n?await async function(n=u){const o=await CommandBar.showOptions(n.map((n=>n.name)),"Select sort order:");return n[o.index].sortFields}():t;console.log("\n"),console.log("\tFinished getUserSort, now sortTasksInNote");const s=null!==e||await async function(){return await o("Include Task Type headings in the output?",[{label:"Yes",value:!0},{label:"No",value:!1}],!0)}();console.log("\tFinished wantHeadings()=".concat(String(s),", now sortTasksInNote"));const l=d(Editor.note,a);console.log("\tFinished sortTasksInNote, now deleteExistingTasks"),await async function(n,o,t=!0){for(const e of c){console.log("Deleting ".concat(o[e].length," ").concat(e," tasks from note")),t&&await f(o[e]);try{const t=o[e].map(!!n&&(o=>h(n,o.raw)));Editor.note.removeParagraphs(t)}catch(n){console.log(JSON.stringify(n))}}}(Editor.note,l,true),console.log("\tFinished deleteExistingTasks, now writeOutTasks"),await async function(n,o,t=!1,e){const a={open:"Open Tasks",scheduled:"Scheduled Tasks",done:"Completed Tasks",cancelled:"Cancelled Tasks"},s=c.slice().reverse();for(let c=0;c<s.length;c++){const l=s[c];if(o[l].length){console.log("EDITOR_FILE TASK_TYPE=".concat(l));try{n&&await p(n,o[l],e?"### ".concat(a[l],":"):"",t?"".concat(c===o[l].length-1?"---":""):"")}catch(n){console.log(JSON.stringify(n))}}}}(Editor.note,l,!1,s),console.log("\tFinished writeOutTasks, now finished"),console.log("Finished sortTasks()!")},Object.defineProperty(n,"__esModule",{value:!0}),n}({});Object.assign(globalThis,exports);
